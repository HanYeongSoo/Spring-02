2022-02-16

	1. 프로젝트 생성
		.- start.spring.io 가서 생성
		.- gradle.build로 프로잭트 불러온 후 file -> settings -> gradle검색 후 실행환경 인텔리제이로 변경

	2. 비즈니스 요구사항과 설계
		
	3. 회원 도메인 설계
		.- 도메인 협력 관계 -> 클래스 다이어그램(정적) -> 객체 다이어그램(동적) (뒤로 갈수록 좀 더 자세한 관계로 설명)

	4. 회원 도메인 개발
		.- HashMap에서 동시성 이슈?? 발생이 있을 수 있음 (실무에선)
	
		.- Grade 이라는 Enum생성 (Enum이 뭐지...)
		.- Member 객체 생성
		.- MemberService 인터페이스, MemberServiceImpl 생성
		.- MemberRepository 인터페이스 , MemoryMemberRepository 생성

	5. 회원 도메인 실행과 테스트
		.- 결과 확인은 항상 test쪽에서 하는게 좋음
		.- 초록불 ok! 빨간불 no..

	6. 주문과 할인 도메인 설계
		.- 아직 무엇을 정확하게 사용할 지 모를 때
		.- 주문 서비스 구현체를 만들어 두면 그떄그떄 변경이 아주 용이함

	7. 주문과 할인 도메인 개발
		.- 회원도메인과 구조는 비슷
	
	8. 주문과 할인 도메인 실행과 테스트
		.- 회원도메인과 구조는 비슷


** 새로운 할인 정책을 추가해주세요 라는 요구가 갑자기 들어옴 ** 

	

2022-02-17

	1. 관심사의 분리가 필요함
		.- 너무 구체적으로 구현체를 선정할 필요가 없음
		.- 배우가 상대배우를 섭외하지 않음 -> 공연 기획자가 섭외를 담당해야함
		.- 공연 기획자를 만들어야함 (AppConfig로 생성)

		.- AppConfig class 생성
		.- MemberService를 생성
		.- 생성자를 통해서 객체를 주입 => '생성자 주입' 이라고 함
		.- 이제부터 객체생성은 AppConfig에서 하고, Member(Order)ServiceImpl에서는 생성자에 들어온 값을 토대로 실행만!!

		.- 이것이 DI(Dependency Injection) 의존관계 주입, 의존성 주입이라고 한다.

	
	2. AppConfig 리팩토링
		.- 기존의 코드를 조금 더 분리하여 사용

		** 기존의 FixDiscount를 RateDiscount로 바꾸고 싶다 **
		.- 어디 부분을 수정하면 될까 ?
		.- AppConfig만 수정하면 된다!!

	3. 위의 사항들을 잘 지키고 코드를 구성하였다면 SRP, DIP, OCP를 잘 지켰다고 볼 수 있다.
		.- SRP(단일 책임 원칙) -> 객체 생성과 연결은 config에서 담당
		.- DIP(의존관계 역전 원칙) -> 클라이언트가 추상화 인터페이스에만 의존하도록 설정
		.- OCP(확장에는 열려있고 변경에는 닫혀있어야 함) -> config에서 의존관계만 바꿔주면 됨

	
	4. IoC, DI, 컨테이너

	** 여기서부터 Spring 그 자체를 알아보자 ** 
	
	5. 스프링으로 AppConfig 바꿔보기
		.- ApplicationContext 를 스프링 컨테이너라고 함
		.- @Configuration이 붙은 'AppConfig'를 설정(구성)정보로 사용하고 여기서 @Bean이 달린 메소드를 모두 호출한 후, 반환된 객체를
			스프링 컨테이너에 등록한다. => 스프링 빈 이라고 함
		.- 스프링빈은 applicationContext.getBean()메소드로 찾을 수 있음 getBean()에서 (@Bean으로 등록한 메소드랑 이름 같게, 그 실제 메소드.class)로 호출
		.- 코드가 더 복잡하고 뭔 첨보는것들을 쓰는데...ㅠㅠ

	6. 컨테이너에 등록된 모든 빈 조회하기
		.- ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.
		.- ac.getBean() : 빈 이름으로 객체(인스턴스)를 조회한다.

		.- Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈
             	.- Role ROLE_INFRASTRUCTURE: 스프링 내부에서 사용하는 빈

	
2022-02-18

	1. 스프링 빈 조회 - 기본
		.- 가장 기본적인 조회 방법 -> ac.getBean(빈이름, 타입) or ac.getBean(타입)
		.- 조회 대상 스프링 빈이 없으면 NoSuchBeanDefinitionException 예외 발생

	2. 스프링 빈 조회 - 동일한 타입이 둘 이상
		.- ac.getBeansOfType() 을 사용하면 해당 타입의 모든 빈을 조회할 수 있다.
		.- 동일한 타입의 빈이 둘 이상이면 오류가 발생 -> 빈 이름을 설정해주면 됨

	3. 스프링 빈 조회 - 상속 관계
		.- 최고 부모인 object타입으로 조회하면 모든 스프링 빈이 나옴
		
	** 위에 1,2,3번은 실제로 많이 쓰진 않을것 이지만 개념은 알고 있는게 좋음**

2022-02-21

	1. ApplicationContext 와 BeanFactory
		.- BeanFactory가 상위, 이걸 상속 받고 사용하는것이 ApplicationContext
		.- ApplicationContext를 주로 사용
		.- 여러 부가적인 기능이 존재

	2. 다양한 설정 형식 지원 - 자바 코드, XML
		.- xml파일 설정 코드로 확인 (처음에 @Bean으로 만든 appConfig.class와 거의 거의 코드가 유사함)

	3. 스프링 빈 설정 메타 정보 - BeanDefinition
		.- 요즘은 이걸로 하긴하는데 자동으로 BeanDefinition이 추상화를 해주기 때문에 개발자가 이게 .class에서 온건지
			.xml에서 온건지 몰라도 된다고는 한다.
		.- 막 이 내용에 대해서 깊게 알려고 안해도 된다고 한다...!


2022-02-22

	1. 웹 어플리케이션과 싱글톤
		.- 처음에 만든 AppConfig.class는 요청할 때 마다 객체가 생성됨  == 메모리 낭비가 심함
		.- 객체를 1개만 생성하고 그 객체를 공유하면 됨 == 싱글톤 패턴

	2. 싱글톤 패턴
		.- 하나의 객체를 공유해서 효율적으로 관리가 가능하지만....단점이 좀 많음
		.- 단점 : 코드도 직접 입력해야하고, DIP 위반, OCP위반, 테스트하기 번거로움등등...
		.- 그럼 쓰라는 거야 말라는거야..?

2022-02-23
	
	3. 싱글톤 컨테이너
		.- 각 클라이언트의 요청에 따라서 동일한 MemberService를 반환함
		.- 즉 하나의 객체로 재사용이 가능함

	4. ** 중요 ** 싱글톤 방식의 주의점
		.- 스프링 빈은 항상 stateless(무상태)로 설정해야함
		.- 같은 객체를 공유하다보니까 멀티쓰레드(잘 몰라..)가 발생했을 시 나는 1만원을 요구했는데 중간에 다른사람이
			2만원을 요구한게 고대로 들어오는 경우가 발생함 (돈 문제 발생하면 난리나겠지?)
		.- 변수로 price를 설정해서 this.price로 받는 것이 아닌 반환값을 int로 한 후 return을 price로 받아야 함
		.- 그럼 어떤 클라이언트의 요청에 상관없이 그 순간 자신의 값은 return받기 때문에 다른 클라이언트에 영향을 받지 않음

	5. @Configuration과 싱글톤
		.- memberRepository가 3번 호출되는게 맞는거 같은데 정작 1번만 호출되었다..!?
	
	6. @Configuration과 바이트코드 조작의 마법!
		.- bean을 출력했는데 bean.getClass() = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$7afd499e 이러케 나왔는디
		.- $$EnhancerBySpringCGLIB$$7afd499e 이 부분이 뭐지?
		.- 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고
		 	그 다른 클래스를 스프링 빈으로 등록한 것!
		.- 즉 스프링 조작과 관련된 부분은 @Configuration을 박고 시작하자









